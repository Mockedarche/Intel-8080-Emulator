use std::{fs, usize};

/*
 * Todo
 * Implement 0x76 HALT fully as of right now just returns a StepInteructionResult
 * with a half to notify whatever is running the i8080 core
 * Finish rest of opcodes
 */

pub enum LoadRomResult {
    Ok,
    Error,
    NotFound,
}

pub enum StepInstructionResult {
    Ok,
    Error,
    NotKnownOpcode,
    NoOperation,
    Halt,
}

const MEMORY_SIZE: usize = 65536;

/*
 * get_twos_compliment - Helper Function
 * Expects: N/A
 * Does: Takes a u8 value and returns the twos compliment of it
 * Returns: Twos compliment of the given u8 value
 */
pub fn get_twos_compliment(value: u8) -> u8 {
    (!value).wrapping_add(1)
}

pub struct I8080Core {
    pub memory: [u8; MEMORY_SIZE],

    pub a: u8,
    pub b: u8,
    pub c: u8,
    pub d: u8,
    pub e: u8,
    pub h: u8,
    pub l: u8,

    pub program_counter: u16,
    pub stack_pointer: u16,

    pub sign: bool,
    pub zero: bool,
    pub auxiliary_carry: bool,
    pub parity: bool,
    pub carry: bool,
}

impl I8080Core {
    pub fn new() -> Self {
        Self {
            memory: [0; MEMORY_SIZE],
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            e: 0,
            h: 0,
            l: 0,

            program_counter: 0,
            stack_pointer: 0,
            sign: false,
            zero: false,
            auxiliary_carry: false,
            parity: false,
            carry: false,
        }
    }

    pub fn i8080_load_rom(&mut self, path: &str) -> LoadRomResult {
        match fs::read(path) {
            Ok(data) => {
                if data.len() > self.memory.len() {
                    return LoadRomResult::Error;
                }
                let len = data.len();
                self.memory[..len].copy_from_slice(&data[..len]);
                LoadRomResult::Ok
            }
            Err(ref e) if e.kind() == std::io::ErrorKind::NotFound => LoadRomResult::NotFound,
            Err(_) => LoadRomResult::Error,
        }
    }
    /*
     * set_zero_flag - Function
     * Expects: self to be intialized and value to be valid data (which is to say the resulting value of
     * an opcode)
     * Does: Sets the i8080Core objects zero flag if value is zero to true else false
     */
    pub fn set_zero_flag(&mut self, value: u8) {
        self.zero = value == 0;
    }

    /*
     * set_sign_flag - Function
     * Expects: self to be intiialized and value to be valid data (which is to say the resulting value of
     * an opcode)
     * Does: Sets the i8080Core objects sign flag if value's most sig bit is 1 to true else false
     */
    pub fn set_sign_flag(&mut self, value: u8) {
        self.sign = (value >> 7) == 1;
    }

    /*
     * set_auxiliary_carry_addition_flag - Function
     * Expects: self to be initialized and value to be valid data (which is to say the resulting value of
     * an opcode)
     * Does: Sets the i8080Core objects auxiliary carry flag if the most sig bit of the first nibble becomes the
     * first bit of the second nibble EX: 0x0F + 0x01 = 0x10
     */
    pub fn set_auxiliary_carry_addition_flag(&mut self, first: u8, second: u8, result: u8) {
        self.auxiliary_carry = ((first ^ second ^ result) & 0x10) != 0;
    }

    /*
     * set_auxiliary_carry_subtraction_flag - Function
     * Expects: self to be initialized and value to be valid data (which is to say the resulting value of
     * an opcode)
     * Does: Sets the i8080Core objects auxiliary carry flag if the lower nibble needed a borrow
     */
    pub fn set_auxiliary_carry_subtraction_flag(&mut self, first: u8, second: u8) {
        self.auxiliary_carry = (first & 0x0F) < (second & 0x0F);
    }

    /*
     * set_parity_flag - Function
     * Expects: self to be initialized and value to be valid data (which is to say the resulting value of
     * an opcode)
     * Does: Sets the i8080Core objects parity flag if last 8 bits of value are an even amount of 1 then true
     * else false
     */
    pub fn set_parity_flag(&mut self, result: u16) {
        let low_eight = result & 0xFF;
        let mut count = 0;
        for i in 0..8 {
            if (low_eight & (1 << i)) != 0 {
                count += 1;
            }
        }
        self.parity = (count % 2) == 0;
    }

    /*
     * set_carry_flag_rotate - Function
     * Epects: self to be initialized and value to be valid data (which is to say its the correct registers value)
     * Does: Sets carry flag to the most sig bit of the value
     */
    pub fn set_carry_flag_rotate(&mut self, value: u8) {
        self.carry = (value & 0x80) != 0;
    }

    /*
     * set_carry_flag_arithmetic_addition - Function
     * Epects: self to be initialized and value to be valid data (which is to say its the correct registers value)
     * Does: Sets the carry flag if the 9th bit is 1 indicating the u8 arithmetic actually overflowed
     */
    pub fn set_carry_flag_arithmetic_addition(&mut self, value: u16) {
        self.carry = (value & 0x0100) != 0;
    }

    /*
     * set_carry_flag_arithmetic_subtraction - Function
     * Epects: self to be initialized and value to be valid data (which is to say its the correct registers value)
     * Does: Sets the carry flag if a borrow occured in a subtraction
     */
    pub fn set_carry_flag_arithmetic_subtraction(&mut self, first: u8, second: u8) {
        self.carry = first < second;
    }

    /*
     * i8080_step - Function
     * Epxects: self to be initialized
     * Does: Performs one instruction (the one pointed at by the program counter)
     * Returns:
     */
    pub fn i8080_step(&mut self) -> StepInstructionResult {
        let mut instruction: u8;
        let mut temp1_8: u8;
        let mut temp2_8: u8;
        let mut temp3_16: u16;

        instruction = self.memory[self.program_counter as usize];

        match instruction {
            0x00 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x01 => {
                self.c = self.memory[(self.program_counter as usize) + 1];
                self.b = self.memory[(self.program_counter as usize) + 2];
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x02 => {
                self.memory[(((self.b as u16) << 8) | self.c as u16) as usize] = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x03 => {
                temp3_16 = (self.b as u16) << 8 | (self.c as u16);
                temp3_16 = temp3_16.wrapping_add(1);
                self.b = (temp3_16 >> 8) as u8;
                self.c = (temp3_16 & 0x00FF) as u8;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x04 => {
                self.b = self.b.wrapping_add(1);
                self.set_sign_flag(self.b);
                self.set_zero_flag(self.b);
                self.set_auxiliary_carry_addition_flag(self.b - 1, 1, self.b);
                self.set_parity_flag(self.b as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x05 => {
                self.b = self.b.wrapping_sub(1);
                self.set_sign_flag(self.b);
                self.set_zero_flag(self.b);
                self.set_auxiliary_carry_addition_flag(self.b + 1, get_twos_compliment(1), self.b);
                self.set_parity_flag(self.b as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x06 => {
                self.b = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x07 => {
                self.set_carry_flag_rotate(self.a);
                self.a = self.a << 1 | if self.carry { 1 } else { 0 };
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x08 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x09 => {
                let mut hl = (self.h as u16) << 8 | self.l as u16;
                let bc = (self.b as u16) << 8 | self.c as u16;
                let sum = hl.wrapping_add(bc);
                self.carry = sum < hl;
                self.h = (sum >> 8) as u8;
                self.l = sum as u8;
                return StepInstructionResult::Ok;
            }
            0x0A => {
                self.a = self.memory[(((self.b as u16) << 8) | self.c as u16) as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x0B => {
                temp3_16 = (self.b as u16) << 8 | self.c as u16;
                temp3_16 = temp3_16.wrapping_sub(1);
                self.b = (temp3_16 >> 8) as u8;
                self.c = (temp3_16 & 0x00FF) as u8;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x0C => {
                self.c = self.c.wrapping_add(1);
                self.set_sign_flag(self.c);
                self.set_zero_flag(self.c);
                self.set_auxiliary_carry_addition_flag(self.c - 1, 1, self.c);
                self.set_parity_flag(self.c as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x0D => {
                self.c = self.c.wrapping_sub(1);
                self.set_sign_flag(self.c);
                self.set_zero_flag(self.c);
                self.set_auxiliary_carry_addition_flag(self.c + 1, get_twos_compliment(1), self.c);
                self.set_parity_flag(self.c as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x0E => {
                self.c = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x0F => {
                self.set_carry_flag_rotate(self.a);
                self.a = (self.a >> 1) | if self.carry { 0x80 } else { 0 };
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x10 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x11 => {
                self.e = self.memory[(self.program_counter as usize) + 1];
                self.d = self.memory[(self.program_counter as usize) + 2];
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x12 => {
                self.memory[(((self.d as u16) << 8) | self.e as u16) as usize] = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x13 => {
                temp3_16 = (self.d as u16) << 8 | (self.e as u16);
                temp3_16 = temp3_16.wrapping_add(1);
                self.d = (temp3_16 >> 8) as u8;
                self.e = (temp3_16 & 0x00FF) as u8;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x14 => {
                self.d = self.d.wrapping_add(1);
                self.set_sign_flag(self.d);
                self.set_zero_flag(self.d);
                self.set_auxiliary_carry_addition_flag(self.d - 1, 1, self.d);
                self.set_parity_flag(self.d as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x15 => {
                self.d = self.d.wrapping_sub(1);
                self.set_sign_flag(self.d);
                self.set_zero_flag(self.d);
                self.set_auxiliary_carry_addition_flag(self.d + 1, get_twos_compliment(1), self.d);
                self.set_parity_flag(self.d as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x16 => {
                self.d = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x17 => {
                let temp_bool = self.carry;
                self.set_carry_flag_rotate(self.a);
                self.a = self.a << 1 | if temp_bool { 1 } else { 0 };
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x18 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x19 => {
                let mut hl = (self.h as u16) << 8 | self.l as u16;
                let de = (self.d as u16) << 8 | self.e as u16;
                let sum = hl.wrapping_add(de);
                self.carry = sum < hl;
                self.h = (sum >> 8) as u8;
                self.l = sum as u8;
                return StepInstructionResult::Ok;
            }
            0x1A => {
                self.a = self.memory[(((self.d as u16) << 8) | self.e as u16) as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x1B => {
                temp3_16 = (self.d as u16) << 8 | self.e as u16;
                temp3_16 = temp3_16.wrapping_sub(1);
                self.d = (temp3_16 >> 8) as u8;
                self.e = (temp3_16 & 0x00FF) as u8;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x1C => {
                self.e = self.e.wrapping_add(1);
                self.set_sign_flag(self.e);
                self.set_zero_flag(self.e);
                self.set_auxiliary_carry_addition_flag(self.e - 1, 1, self.e);
                self.set_parity_flag(self.e as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x1D => {
                self.e = self.e.wrapping_sub(1);
                self.set_sign_flag(self.e);
                self.set_zero_flag(self.e);
                self.set_auxiliary_carry_addition_flag(self.e + 1, get_twos_compliment(1), self.e);
                self.set_parity_flag(self.e as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x1E => {
                self.e = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x1F => {
                let temp_bool = self.carry;
                self.set_carry_flag_rotate(self.a);
                self.a = (self.a >> 1) | if temp_bool { 0x80 } else { 0 };
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x20 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x21 => {
                self.h = self.memory[(self.program_counter as usize) + 1];
                self.l = self.memory[(self.program_counter as usize) + 2];
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x22 => {
                let addr = (self.memory[(self.program_counter as usize) + 2] as u16) << 8
                    | (self.memory[(self.program_counter as usize) + 1] as u16);
                self.memory[addr as usize] = self.l;
                self.memory[addr as usize + 1] = self.h;
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x23 => {
                temp3_16 = (self.h as u16) << 8 | (self.l as u16);
                temp3_16 = temp3_16.wrapping_add(1);
                self.h = (temp3_16 >> 8) as u8;
                self.l = (temp3_16 & 0x00FF) as u8;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x24 => {
                self.h = self.h.wrapping_add(1);
                self.set_sign_flag(self.h);
                self.set_zero_flag(self.h);
                self.set_auxiliary_carry_addition_flag(self.h - 1, 1, self.h);
                self.set_parity_flag(self.h as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x25 => {
                self.h = self.h.wrapping_sub(1);
                self.set_sign_flag(self.h);
                self.set_zero_flag(self.h);
                self.set_auxiliary_carry_addition_flag(self.h + 1, get_twos_compliment(1), self.h);
                self.set_parity_flag(self.h as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x26 => {
                self.h = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x27 => {
                let mut sum = self.a as u16;
                if ((self.a & 0x0F) > 9 || self.auxiliary_carry) {
                    sum += 6;
                    self.set_auxiliary_carry_addition_flag(self.a, 6, self.a.wrapping_add(6));
                    self.a = self.a.wrapping_add(6);
                }
                if (((self.a & 0xF0) >> 4) > 9 || self.carry) {
                    sum = self.a as u16 + 0x60;
                    self.a = self.a.wrapping_add(0x60);
                }
                self.set_carry_flag_arithmetic_addition(sum);
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x28 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x29 => {
                let mut hl = (self.h as u16) << 8 | self.l as u16;
                let sum = hl.wrapping_add(hl);
                self.carry = sum < hl;
                self.h = (sum >> 8) as u8;
                self.l = sum as u8;
                return StepInstructionResult::Ok;
            }
            0x2A => {
                let addr = (self.memory[(self.program_counter as usize) + 2] as u16) << 8
                    | (self.memory[(self.program_counter as usize) + 1] as u16);
                self.l = self.memory[addr as usize];
                self.h = self.memory[addr as usize + 1];
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x2B => {
                temp3_16 = (self.h as u16) << 8 | self.l as u16;
                temp3_16 = temp3_16.wrapping_sub(1);
                self.h = (temp3_16 >> 8) as u8;
                self.l = (temp3_16 & 0x00FF) as u8;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x2C => {
                self.l = self.l.wrapping_add(1);
                self.set_sign_flag(self.l);
                self.set_zero_flag(self.l);
                self.set_auxiliary_carry_addition_flag(self.l - 1, 1, self.l);
                self.set_parity_flag(self.l as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x2D => {
                self.l = self.l.wrapping_sub(1);
                self.set_sign_flag(self.l);
                self.set_zero_flag(self.l);
                self.set_auxiliary_carry_addition_flag(self.l + 1, get_twos_compliment(1), self.l);
                self.set_parity_flag(self.l as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x2E => {
                self.l = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x2F => {
                self.a = !self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x30 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x31 => {
                self.stack_pointer = (self.memory[(self.program_counter as usize) + 1] as u16) << 8
                    | self.memory[(self.program_counter as usize) + 2] as u16;
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x32 => {
                let addr = (self.memory[(self.program_counter as usize) + 2] as u16) << 8
                    | (self.memory[(self.program_counter as usize) + 1] as u16);
                self.memory[addr as usize] = self.a;
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x33 => {
                self.stack_pointer = self.stack_pointer.wrapping_add(1);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x34 => {
                self.h = self.h.wrapping_add(1);
                self.set_sign_flag(self.h);
                self.set_zero_flag(self.h);
                self.set_auxiliary_carry_addition_flag(self.h - 1, 1, self.h);
                self.set_parity_flag(self.h as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x35 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);

                self.memory[addr as usize] = self.memory[addr as usize].wrapping_sub(1);

                self.set_sign_flag(self.memory[addr as usize]);
                self.set_zero_flag(self.memory[addr as usize]);
                self.set_auxiliary_carry_addition_flag(
                    self.memory[addr as usize] + 1,
                    get_twos_compliment(1),
                    self.memory[addr as usize],
                );
                self.set_parity_flag(self.memory[addr as usize] as u16);
                self.program_counter = self.program_counter.wrapping_add(1);

                return StepInstructionResult::Ok;
            }
            0x36 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);

                self.memory[addr as usize] = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x37 => {
                self.carry = true;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x38 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::NoOperation;
            }
            0x39 => {
                let mut hl = (self.h as u16) << 8 | self.l as u16;
                let sum = hl.wrapping_add(self.stack_pointer);
                self.carry = sum < hl;
                self.h = (sum >> 8) as u8;
                self.l = sum as u8;
                return StepInstructionResult::Ok;
            }
            0x3A => {
                let addr = (self.memory[(self.program_counter as usize) + 2] as u16) << 8
                    | (self.memory[(self.program_counter as usize) + 1] as u16);

                self.a = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(3);
                return StepInstructionResult::Ok;
            }
            0x3B => {
                self.stack_pointer = self.stack_pointer.wrapping_sub(1);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x3C => {
                self.a = self.a.wrapping_add(1);
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_auxiliary_carry_addition_flag(self.a - 1, 1, self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x3D => {
                self.a = self.a.wrapping_sub(1);
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_auxiliary_carry_addition_flag(self.a + 1, get_twos_compliment(1), self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x3E => {
                self.a = self.memory[(self.program_counter as usize) + 1];
                self.program_counter = self.program_counter.wrapping_add(2);
                return StepInstructionResult::Ok;
            }
            0x3F => {
                self.carry = !self.carry;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x40 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x41 => {
                self.b = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x42 => {
                self.b = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x43 => {
                self.b = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x44 => {
                self.b = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x45 => {
                self.b = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x46 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.b = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x47 => {
                self.b = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x48 => {
                self.c = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x49 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x4A => {
                self.c = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x4B => {
                self.c = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x4C => {
                self.c = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x4D => {
                self.c = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x4E => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.c = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x4F => {
                self.c = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x50 => {
                self.d = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x51 => {
                self.d = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x52 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x53 => {
                self.d = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x54 => {
                self.d = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x55 => {
                self.d = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x56 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.d = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x57 => {
                self.d = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x58 => {
                self.e = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x59 => {
                self.e = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x5A => {
                self.e = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x5B => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x5C => {
                self.e = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x5D => {
                self.e = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x5E => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.e = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x5F => {
                self.e = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x60 => {
                self.h = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x61 => {
                self.h = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x62 => {
                self.h = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x63 => {
                self.h = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x64 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x65 => {
                self.h = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x66 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.h = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x67 => {
                self.h = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x68 => {
                self.l = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x69 => {
                self.l = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x6A => {
                self.l = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x6B => {
                self.l = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x6C => {
                self.l = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x6D => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x6E => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.l = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x6F => {
                self.l = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x70 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x71 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x72 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x73 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x74 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x75 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x76 => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Halt;
            }
            0x77 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.memory[addr as usize] = self.a;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x78 => {
                self.a = self.b;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x79 => {
                self.a = self.c;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x7A => {
                self.a = self.d;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x7B => {
                self.a = self.e;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x7C => {
                self.a = self.h;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x7D => {
                self.a = self.l;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x7E => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                self.a = self.memory[addr as usize];
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x7F => {
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x80 => {
                let sum = self.a as u16 + self.b as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.b, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x81 => {
                let sum = self.a as u16 + self.c as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.c, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x82 => {
                let sum = self.a as u16 + self.d as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.d, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x83 => {
                let sum = self.a as u16 + self.e as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.e, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x84 => {
                let sum = self.a as u16 + self.h as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.h, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x85 => {
                let sum = self.a as u16 + self.l as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.l, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x86 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let sum = self.a as u16 + self.memory[addr as usize] as u16;
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.memory[addr as usize],
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x87 => {
                let sum = self.a as u16 + self.a as u16;
                self.set_auxiliary_carry_addition_flag(self.a, self.a, sum as u8);
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x88 => {
                let sum = self.a as u16 + self.b as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.b.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x89 => {
                let sum = self.a as u16 + self.c as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.c.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x8A => {
                let sum = self.a as u16 + self.d as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.d.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x8B => {
                let sum = self.a as u16 + self.e as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.e.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x8C => {
                let sum = self.a as u16 + self.h as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.h.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x8D => {
                let sum = self.a as u16 + self.l as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.l.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x8E => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let sum = self.a as u16
                    + self.memory[addr as usize] as u16
                    + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.memory[addr as usize].wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x8F => {
                let sum = self.a as u16 + self.a as u16 + if self.carry { 1 } else { 0 };
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    self.a.wrapping_add(if self.carry { 1 } else { 0 }),
                    sum as u8,
                );
                self.a = sum as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.set_carry_flag_arithmetic_addition(sum);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x90 => {
                let dif = self.a as u16 - self.b as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.b);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.b);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x91 => {
                let dif = self.a as u16 - self.c as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.c);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.c);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x92 => {
                let dif = self.a as u16 - self.d as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.d);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.d);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x93 => {
                let dif = self.a as u16 - self.e as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.e);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.e);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x94 => {
                let dif = self.a as u16 - self.h as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.h);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.h);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x95 => {
                let dif = self.a as u16 - self.l as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.l);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.l);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x96 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let value_from_memory = self.memory[addr as usize] as u8;
                let dif = self.a as u16 - value_from_memory as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, value_from_memory);
                self.set_carry_flag_arithmetic_subtraction(self.a, value_from_memory);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x97 => {
                let dif = self.a as u16 - self.a as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.a);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.a);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x98 => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.b as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.b + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.b + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x99 => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.c as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.c + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.c + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x9A => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.d as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.d + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.d + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x9B => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.e as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.e + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.e + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x9C => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.h as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.h + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.h + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x9D => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.l as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.l + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.l + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x9E => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let value_from_memory = self.memory[addr as usize] as u8;
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - value_from_memory as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(
                    self.a,
                    value_from_memory + carry_value as u8,
                );
                self.set_carry_flag_arithmetic_subtraction(
                    self.a,
                    value_from_memory + carry_value as u8,
                );
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0x9F => {
                let carry_value = if self.carry { 1 } else { 0 };
                let dif = self.a as u16 - self.a as u16 - carry_value;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.a + carry_value as u8);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.a + carry_value as u8);
                self.a = dif as u8;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA0 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.b, self.a & self.b);
                self.a = self.a & self.b;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA1 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.c, self.a & self.c);
                self.a = self.a & self.c;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA2 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.d, self.a & self.d);
                self.a = self.a & self.d;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA3 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.e, self.a & self.e);
                self.a = self.a & self.e;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA4 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.h, self.a & self.h);
                self.a = self.a & self.h;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA5 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.l, self.a & self.l);
                self.a = self.a & self.l;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA6 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let value_from_memory = self.memory[addr as usize] as u8;
                self.set_auxiliary_carry_addition_flag(
                    self.a,
                    value_from_memory,
                    self.a & value_from_memory,
                );
                self.a = self.a & value_from_memory;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA7 => {
                self.set_auxiliary_carry_addition_flag(self.a, self.a, self.a & self.a);
                self.a = self.a & self.a;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA8 => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.b;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xA9 => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.c;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xAA => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.d;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xAB => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.e;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xAC => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.h;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xAD => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.l;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xAE => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let value_from_memory = self.memory[addr as usize] as u8;
                self.auxiliary_carry = false;
                self.a = self.a ^ value_from_memory;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xAF => {
                self.auxiliary_carry = false;
                self.a = self.a ^ self.a;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB0 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.b;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB1 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.c;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB2 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.d;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB3 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.e;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB4 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.h;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB5 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.l;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB6 => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let value_from_memory = self.memory[addr as usize] as u8;
                self.auxiliary_carry = false;
                self.a = self.a | value_from_memory;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB7 => {
                self.auxiliary_carry = false;
                self.a = self.a | self.a;
                self.set_sign_flag(self.a);
                self.set_zero_flag(self.a);
                self.set_parity_flag(self.a as u16);
                self.carry = false;
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB8 => {
                let dif = self.a as u16 - self.b as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.b);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.b);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xB9 => {
                let dif = self.a as u16 - self.c as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.c);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.c);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xBA => {
                let dif = self.a as u16 - self.d as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.d);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.d);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xBB => {
                let dif = self.a as u16 - self.e as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.e);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.e);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xBC => {
                let dif = self.a as u16 - self.h as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.h);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.h);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xBD => {
                let dif = self.a as u16 - self.l as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.l);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.l);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xBE => {
                let addr = (self.h as u16) << 8 | (self.l as u16);
                let value_from_memory = self.memory[addr as usize] as u8;
                let dif = self.a as u16 - value_from_memory as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, value_from_memory);
                self.set_carry_flag_arithmetic_subtraction(self.a, value_from_memory);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xBF => {
                let dif = self.a as u16 - self.a as u16;
                self.set_auxiliary_carry_subtraction_flag(self.a, self.a);
                self.set_carry_flag_arithmetic_subtraction(self.a, self.a);
                self.set_sign_flag(dif as u8);
                self.set_zero_flag(dif as u8);
                self.set_parity_flag(dif as u16);
                self.program_counter = self.program_counter.wrapping_add(1);
                return StepInstructionResult::Ok;
            }
            0xC0..=0xFF => {
                return StepInstructionResult::Ok;
            }
        }
    }
}
